<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-config-udev">
  <?dbhtml filename="udev.html"?>

  <title>장치 및 모듈 핸들링 개요</title>

  <indexterm zone="ch-config-udev">
    <primary sortas="a-Udev">Udev</primary>
    <secondary>usage</secondary>
  </indexterm>

  <para><xref linkend="chapter-building-system"/>에서 우리는, <phrase revision="systemd">systemd</phrase><phrase revision="sysv">eudev</phrase>가 빌드될 때 Udev 패키지를 설치했다. 이들의 작동 방식에 대한 자세한 내용을 살펴보기 전에, 예전의 장치 핸들링 방법에 관한 간단한 역사에 대해 짚고 넘어가고자 한다.</para>

  <para>일반적인 리눅스 시스템은 전통적으로 정적인 장치 생성 방법을 사용해서, 해당 하드웨어 장치가 실제로 존재하는지 여부에 관계없이 <filename class="directory">/dev</filename> 아래에 매우 많은 장치 노드(때로는 문자 그대로 수천 개의 노드)가 만들어졌다. 이는 일반적으로 <command>MAKEDEV</command> 스크립트를 통해 이뤄졌는데, 이 스크립트는 세상에 존재할 수 있는 모든 장치에 대한 관련 주/부 장치 번호와 함께 <command>mknod</command> 프로그램에 대한 여러 호출들을 담고 있었다.</para>

  <para>Udev를 사용하면 커널에 의해 탐지된 장치만 해당 장치 노드가 생성된다. 이런 장치 노드는 시스템이 부팅될 때마다 생성되기 때문에 <systemitem class="filesystem">devtmpfs</systemitem> 파일 시스템(완전히 시스템 메모리에 상주하는 가상 파일 시스템)에 저장된다. 장치 노드는 공간이 많이 필요하지 않기 때문에 사용되는 메모리는 무시할 수 있다.</para>

  <sect2>
    <title>역사</title>

    <para>2000년 2월, <systemitem class="filesystem">devfs</systemitem>라는 새로운 파일 시스템이 2.3.46 커널에 병합되어 2.4 안정 버전 커널 동안 사용할 수 있게 되었다. 커널 소스에 존재함에도 불구하고, 동적으로 장치를 만드는 이 방법은 핵심 커널 개발자들로부터 결코 지지를 받지 못했다.</para>

    <para><systemitem class="filesystem">devfs</systemitem>에서 채택된 접근 방식의 주요 문제는 장치 탐지, 생성 및 명명 처리 방식이었다. 장치 노드 명명 문제인 후자가 아마도 가장 중요한 사안이었을 것이다. 장치 이름을 설정할 수 있는 경우 장치 명명 정책은 특정 개발자가 정하는 것이 아니라 시스템 관리자의 몫이어야 한다는 것이 보편적인 생각이다. 더구나 <systemitem class="filesystem">devfs</systemitem> 파일 시스템은 설계에 내재되어 있어 커널에 대한 실질적인 수정 없이는 고칠 수 없는 경합 조건에 시달렸다. 그것은 유지보수의 부족으로 장기간 폐기된 것으로 표시되었고, 결국 2006년 6월 커널에서 제거되었다.</para>

    <para>나중에 안정된 2.6 버전으로 배포된 2.5 개발 버전 커널 트리가 개발되면서 <systemitem class="filesystem">sysfs</systemitem>라는 새로운 가상 파일 시스템이 생겼다. <systemitem class="filesystem">sysfs</systemitem>의 일은 시스템 하드웨어 구성보기를 사용자 공간프로세스로 내보내는 것이다. 이 사용자 공간에서 볼 수 있는 표현 방식으로 인해, <systemitem class="filesystem">devfs</systemitem>의 사용자 공간용 대체품 개발 가능성이 훨씬 더 현실로 다가왔다.</para>

  </sect2>

  <sect2>
    <title>Udev 구현</title>

    <sect3>
      <title>Sysfs</title>

      <para><systemitem class="filesystem">sysfs</systemitem> 파일 시스템은 위에서 간략히 언급했다. <systemitem class="filesystem">sysfs</systemitem>가 시스템에 존재하는 장치와 어떤 장치 번호를 사용해야 하는지를 어떻게 아는지 궁금할 수 있다. 커널로 컴파일된 드라이버는 커널에 의해 감지되는 대로 자신의 개체를 <systemitem class="filesystem">sysfs</systemitem>(내부적으론 devtmpfs)에 직접 등록한다. 모듈로 컴파일된 드라이버의 경우 모듈이 로드될 때 이 등록이 이루어진다. <systemitem class="filesystem">sysfs</systemitem> 파일 시스템을 마운트하면(/sys에), 드라이버가 <systemitem class="filesystem">sysfs</systemitem>에 등록한 데이터를 사용자 공간 프로세스와 처리를 위한 udevd(장치 노드 수정 포함)에 사용할 수 있다.</para>

    </sect3>

    <sect3>
      <title>Device Node Creation</title>

      <para>Device files are created by the kernel by the <systemitem
      class="filesystem">devtmpfs</systemitem> filesystem.  Any driver that
      wishes to register a device node will go through the <systemitem
      class="filesystem">devtmpfs</systemitem> (via the driver core) to do it.
      When a <systemitem class="filesystem">devtmpfs</systemitem> instance is
      mounted on <filename class="directory">/dev</filename>, the device node
      will initially be created with a fixed name, permissions, and
      owner.</para>

      <para>A short time later, the kernel will send a uevent to <command>
      udevd</command>.  Based on the rules specified in the files within the
      <filename class="directory">/etc/udev/rules.d</filename>, <filename
      class="directory">/lib/udev/rules.d</filename>, and <filename
      class="directory">/run/udev/rules.d</filename> directories, <command>
      udevd</command> will create additional symlinks to the device node, or
      change its permissions, owner, or group, or modify the internal
      <command>udevd</command> database entry (name) for that object.</para>

      <para>The rules in these three directories are numbered and all three
      directories are merged together. If <command>udevd</command> can't find a
      rule for the device it is creating, it will leave the permissions and
      ownership at whatever <systemitem
      class="filesystem">devtmpfs</systemitem> used initially.</para> </sect3>
      
    <sect3 id="module-loading">
      <title>Module Loading</title>

      <para>Device drivers compiled as modules may have aliases built into them.
      Aliases are visible in the output of the <command>modinfo</command>
      program and are usually related to the bus-specific identifiers of devices
      supported by a module. For example, the <emphasis>snd-fm801</emphasis>
      driver supports PCI devices with vendor ID 0x1319 and device ID 0x0801,
      and has an alias of <quote>pci:v00001319d00000801sv*sd*bc04sc01i*</quote>.
      For most devices, the bus driver exports the alias of the driver that
      would handle the device via <systemitem
      class="filesystem">sysfs</systemitem>. E.g., the
      <filename>/sys/bus/pci/devices/0000:00:0d.0/modalias</filename> file
      might contain the string
      <quote>pci:v00001319d00000801sv00001319sd00001319bc04sc01i00</quote>.
      The default rules provided with Udev will cause <command>udevd</command>
      to call out to <command>/sbin/modprobe</command> with the contents of the
      <envar>MODALIAS</envar> uevent environment variable (which should be the
      same as the contents of the <filename>modalias</filename> file in sysfs),
      thus loading all modules whose aliases match this string after wildcard
      expansion.</para>

      <para>In this example, this means that, in addition to
      <emphasis>snd-fm801</emphasis>, the obsolete (and unwanted)
      <emphasis>forte</emphasis> driver will be loaded if it is
      available. See below for ways in which the loading of unwanted drivers can
      be prevented.</para>

      <para>The kernel itself is also able to load modules for network
      protocols, filesystems and NLS support on demand.</para>

    </sect3>

    <sect3>
      <title>Handling Hotpluggable/Dynamic Devices</title>

      <para>When you plug in a device, such as a Universal Serial Bus (USB) MP3
      player, the kernel recognizes that the device is now connected and
      generates a uevent. This uevent is then handled by
      <command>udevd</command> as described above.</para>

    </sect3>

  </sect2>

  <sect2>
    <title>Problems with Loading Modules and Creating Devices</title>

    <para>There are a few possible problems when it comes to automatically
    creating device nodes.</para>

    <sect3>
      <title>A kernel module is not loaded automatically</title>

      <para>Udev will only load a module if it has a bus-specific alias and the
      bus driver properly exports the necessary aliases to <systemitem
      class="filesystem">sysfs</systemitem>. In other cases, one should
      arrange module loading by other means. With Linux-&linux-version;, Udev is
      known to load properly-written drivers for INPUT, IDE, PCI, USB, SCSI,
      SERIO, and FireWire devices.</para>

      <para>To determine if the device driver you require has the necessary
      support for Udev, run <command>modinfo</command> with the module name as
      the argument.  Now try locating the device directory under
      <filename class="directory">/sys/bus</filename> and check whether there is
      a <filename>modalias</filename> file there.</para>

      <para>If the <filename>modalias</filename> file exists in <systemitem
      class="filesystem">sysfs</systemitem>, the driver supports the device and
      can talk to it directly, but doesn't have the alias, it is a bug in the
      driver. Load the driver without the help from Udev and expect the issue
      to be fixed later.</para>

      <para>If there is no <filename>modalias</filename> file in the relevant
      directory under <filename class="directory">/sys/bus</filename>, this
      means that the kernel developers have not yet added modalias support to
      this bus type. With Linux-&linux-version;, this is the case with ISA
      busses. Expect this issue to be fixed in later kernel versions.</para>

      <para>Udev is not intended to load <quote>wrapper</quote> drivers such as
      <emphasis>snd-pcm-oss</emphasis> and non-hardware drivers such as
      <emphasis>loop</emphasis> at all.</para>

    </sect3>

    <sect3>
      <title>A kernel module is not loaded automatically, and Udev is not
      intended to load it</title>

      <para>If the <quote>wrapper</quote> module only enhances the
      functionality provided by some other module (e.g.,
      <emphasis>snd-pcm-oss</emphasis> enhances the functionality of
      <emphasis>snd-pcm</emphasis> by making the sound cards available to OSS
      applications), configure <command>modprobe</command> to load the wrapper
      after Udev loads the wrapped module. To do this, add a
      <quote>softdep</quote> line to the corresponding
      <filename>/etc/modprobe.d/<replaceable>&lt;filename&gt;</replaceable>.conf</filename>
      file. For example:</para>

<screen role="nodump"><literal>softdep snd-pcm post: snd-pcm-oss</literal></screen>

      <para>Note that the <quote>softdep</quote> command also allows
      <literal>pre:</literal> dependencies, or a mixture of both
      <literal>pre:</literal> and <literal>post:</literal>.  See the
      <filename>modprobe.d(5)</filename> manual page for more information
      on <quote>softdep</quote> syntax and capabilities.</para>

      <para>If the module in question is not a wrapper and is useful by itself,
      configure the <command>modules</command> bootscript to load this
      module on system boot. To do this, add the module name to the
      <filename>/etc/sysconfig/modules</filename> file on a separate line.
      This works for wrapper modules too, but is suboptimal in that case.</para>

    </sect3>

    <sect3>
      <title>Udev loads some unwanted module</title>

      <para>Either don't build the module, or blacklist it in a
      <filename>/etc/modprobe.d/blacklist.conf</filename> file as done with the
      <emphasis>forte</emphasis> module in the example below:</para>

<screen role="nodump"><literal>blacklist forte</literal></screen>

      <para>Blacklisted modules can still be loaded manually with the
      explicit <command>modprobe</command> command.</para>

    </sect3>

    <sect3>
      <title>Udev creates a device incorrectly, or makes a wrong symlink</title>

      <para>This usually happens if a rule unexpectedly matches a device. For
      example, a poorly-written rule can match both a SCSI disk (as desired)
      and the corresponding SCSI generic device (incorrectly) by vendor.
      Find the offending rule and make it more specific, with the help of the
      <command>udevadm info</command> command.</para>

    </sect3>

    <sect3>
      <title>Udev rule works unreliably</title>

      <para>This may be another manifestation of the previous problem. If not,
      and your rule uses <systemitem class="filesystem">sysfs</systemitem>
      attributes, it may be a kernel timing issue, to be fixed in later kernels.
      For now, you can work around it by creating a rule that waits for the used
      <systemitem class="filesystem">sysfs</systemitem> attribute and appending
      it to the <filename>/etc/udev/rules.d/10-wait_for_sysfs.rules</filename>
      file (create this file if it does not exist). Please notify the LFS
      Development list if you do so and it helps.</para>

    </sect3>

    <sect3>
      <title>Udev does not create a device</title>

      <para>Further text assumes that the driver is built statically into the
      kernel or already loaded as a module, and that you have already checked
      that Udev doesn't create a misnamed device.</para>

      <para>Udev has no information needed to create a device node if a kernel
      driver does not export its data to
      <systemitem class="filesystem">sysfs</systemitem>. This is most common
      with third party drivers from outside the kernel tree. Create a static
      device node in <filename>/lib/udev/devices</filename> with the
      appropriate major/minor numbers (see the file
      <filename>devices.txt</filename> inside the kernel documentation or the
      documentation provided by the third party driver vendor). The static
      device node will be copied to <filename class="directory">/dev</filename>
      by <command>udev</command>.</para>

    </sect3>

    <sect3>
      <title>Device naming order changes randomly after rebooting</title>

      <para>This is due to the fact that Udev, by design, handles uevents and
      loads modules in parallel, and thus in an unpredictable order. This will
      never be <quote>fixed</quote>. You should not rely upon the kernel device
      names being stable. Instead, create your own rules that make symlinks with
      stable names based on some stable attributes of the device, such as a
      serial number or the output of various *_id utilities installed by Udev.
      See <xref linkend="ch-config-symlinks"/> and
      <xref linkend="ch-config-network"/> for examples.</para>

    </sect3>

  </sect2>

  <sect2>
    <title>Useful Reading</title>

    <para>Additional helpful documentation is available at the following
    sites:</para>

    <itemizedlist>

      <listitem>
        <para>A Userspace Implementation of <systemitem class="filesystem">devfs</systemitem>
        <ulink url="http://www.kroah.com/linux/talks/ols_2003_udev_paper/Reprint-Kroah-Hartman-OLS2003.pdf"/></para>
      </listitem>

      <listitem>
        <para>The <systemitem class="filesystem">sysfs</systemitem> Filesystem
        <ulink url="http://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf"/></para>
      </listitem>

<!--  No longer available
      <listitem>
        <para>Pointers to further reading
        <ulink url="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev.html"/>
        </para>
      </listitem>
-->
    </itemizedlist>

  </sect2>

</sect1>
